"""Generate markdown briefs and reports from analyzed tasks."""

import logging
from typing import Dict, List
from datetime import datetime
from pathlib import Path

logger = logging.getLogger(__name__)


class BriefGenerator:
    """Generates markdown briefs from analyzed and ranked tasks."""

    def __init__(self, output_dir: Path):
        """
        Initialize the brief generator.

        Args:
            output_dir: Directory to save briefs.
        """
        self.output_dir = output_dir
        self.output_dir.mkdir(parents=True, exist_ok=True)

    def generate_daily_brief(self, categorized_tasks: Dict[str, List[Dict]], date: datetime = None) -> str:
        """
        Generate a daily task brief.

        Args:
            categorized_tasks: Tasks categorized by timeframe.
            date: Date for the brief (defaults to today).

        Returns:
            Path to the generated brief file.
        """
        date = date or datetime.now()
        date_str = date.strftime("%Y-%m-%d")

        logger.info(f"Generating daily brief for {date_str}")

        # Build markdown content
        markdown = self._build_brief_markdown(categorized_tasks, date_str)

        # Save to file
        filename = f"daily_brief_{date_str}.md"
        filepath = self.output_dir / filename

        filepath.write_text(markdown, encoding="utf-8")
        logger.info(f"Brief saved to {filepath}")

        return str(filepath)

    def _build_brief_markdown(self, categorized_tasks: Dict[str, List[Dict]], date_str: str) -> str:
        """Build the markdown content for the brief."""
        lines = []

        # Header
        lines.append(f"# Task Brief - {date_str}")
        lines.append("")
        lines.append(f"*Generated at {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}*")
        lines.append("")

        # Summary stats
        total_tasks = sum(len(tasks) for tasks in categorized_tasks.values())
        lines.append("## Summary")
        lines.append("")
        lines.append(f"- **Total Tasks Analyzed:** {total_tasks}")
        lines.append(f"- **Focus Today:** {len(categorized_tasks['today'])}")
        lines.append(f"- **This Week:** {len(categorized_tasks['this_week'])}")
        lines.append(f"- **Later:** {len(categorized_tasks['later'])}")
        lines.append(f"- **Waiting/Blocked:** {len(categorized_tasks['waiting'])}")
        lines.append("")

        # Today's tasks (top priority)
        lines.append("## ðŸŽ¯ Focus Today")
        lines.append("")
        if categorized_tasks["today"]:
            lines.extend(self._format_task_list(categorized_tasks["today"], show_details=True))
        else:
            lines.append("*No high-priority tasks for today. Great job!*")
            lines.append("")

        # This week
        lines.append("## ðŸ“… This Week")
        lines.append("")
        if categorized_tasks["this_week"]:
            lines.extend(self._format_task_list(categorized_tasks["this_week"], show_details=False))
        else:
            lines.append("*No tasks scheduled for this week.*")
            lines.append("")

        # Waiting/Blocked
        if categorized_tasks["waiting"]:
            lines.append("## â¸ï¸ Waiting/Blocked")
            lines.append("")
            lines.extend(self._format_task_list(categorized_tasks["waiting"], show_details=False))

        # Later
        if categorized_tasks["later"]:
            lines.append("## ðŸ“Œ Later")
            lines.append("")
            lines.append(f"*{len(categorized_tasks['later'])} tasks scheduled for later*")
            lines.append("")
            # Show just top 5
            lines.extend(self._format_task_list(categorized_tasks["later"][:5], show_details=False))
            if len(categorized_tasks["later"]) > 5:
                lines.append(f"*...and {len(categorized_tasks['later']) - 5} more*")
                lines.append("")

        # Footer
        lines.append("---")
        lines.append("")
        lines.append("*Generated by Microsoft To Do AI Task Manager*")
        lines.append("")

        return "\n".join(lines)

    def _format_task_list(self, tasks: List[Dict], show_details: bool = True) -> List[str]:
        """Format a list of tasks as markdown."""
        lines = []

        for i, item in enumerate(tasks, 1):
            task = item["task"]
            analysis = item["analysis"]
            score = item["priority_score"]

            # Task header
            title = task.get("title", "Untitled task")
            lines.append(f"### {i}. {title}")
            lines.append("")

            # Priority score
            lines.append(f"**Priority Score:** {score:.1f}/100")
            lines.append("")

            if show_details:
                # Summary
                summary = analysis.get("summary", "")
                if summary:
                    lines.append(f"**Summary:** {summary}")
                    lines.append("")

                # Suggested action
                action = analysis.get("suggested_action", "")
                if action:
                    lines.append(f"**Next Action:** {action}")
                    lines.append("")

                # Key insights
                insights = analysis.get("key_insights", [])
                if insights:
                    lines.append("**Key Insights:**")
                    for insight in insights[:3]:  # Top 3
                        lines.append(f"- {insight}")
                    lines.append("")

                # Metadata
                lines.append("**Details:**")
                lines.append(f"- Category: {analysis.get('category', 'N/A')}")
                lines.append(f"- Urgency: {analysis.get('urgency_level', 'N/A')}")
                lines.append(f"- Est. Time: {analysis.get('estimated_time_minutes', 'N/A')} min")

                due_date = task.get("due_date")
                if due_date:
                    lines.append(f"- Due: {due_date}")

                tags = analysis.get("tags", [])
                if tags:
                    lines.append(f"- Tags: {', '.join(tags)}")

                # URLs
                urls = task.get("urls", [])
                if urls:
                    lines.append("")
                    lines.append("**Links:**")
                    for url in urls[:3]:  # Max 3 URLs
                        lines.append(f"- <{url}>")

                lines.append("")
                lines.append("---")
                lines.append("")

            else:
                # Compact format
                lines.append(f"*{analysis.get('summary', 'No summary available')}*")
                lines.append("")

        return lines

    def generate_weekly_report(self, all_tasks: List[Dict]) -> str:
        """
        Generate a weekly summary report.

        Args:
            all_tasks: All analyzed tasks.

        Returns:
            Path to the generated report file.
        """
        date_str = datetime.now().strftime("%Y-W%W")
        logger.info(f"Generating weekly report for {date_str}")

        lines = []
        lines.append(f"# Weekly Task Report - {date_str}")
        lines.append("")
        lines.append(f"*Generated at {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}*")
        lines.append("")

        # Statistics
        lines.append("## Statistics")
        lines.append("")
        lines.append(f"- Total tasks: {len(all_tasks)}")

        # Category breakdown
        categories = {}
        for item in all_tasks:
            cat = item["analysis"].get("category", "other")
            categories[cat] = categories.get(cat, 0) + 1

        lines.append("")
        lines.append("**By Category:**")
        for cat, count in sorted(categories.items(), key=lambda x: x[1], reverse=True):
            lines.append(f"- {cat}: {count}")

        lines.append("")

        # Top priority tasks
        lines.append("## Top Priority Tasks")
        lines.append("")
        top_tasks = sorted(all_tasks, key=lambda x: x["priority_score"], reverse=True)[:10]
        lines.extend(self._format_task_list(top_tasks, show_details=False))

        # Save
        filename = f"weekly_report_{date_str}.md"
        filepath = self.output_dir / filename
        filepath.write_text("\n".join(lines), encoding="utf-8")

        logger.info(f"Weekly report saved to {filepath}")
        return str(filepath)
